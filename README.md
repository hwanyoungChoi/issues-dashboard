# 지원자가 과제에 대해 직접 작성하는 내용입니다.

## 🛠 기술 스택

> 프로젝트에서 사용한 기술들을 아래 표에 작성해주세요.

| 구분               | 선택한 기술          | 버전          | 선택 이유                                                                                                                                                                                                                                                                                                                    |
| ------------------ | -------------------- | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **프레임워크**     | Next.js              | Latest (15.3) | 안정화된 최신 버전이며 과제를 구현하는데 있어서 호환성 이슈 발생할 것은 없어보였습니다. 따라서 최신 버전으로 설치하였습니다.                                                                                                                                                                                                 |
| **상태 관리**      | zustand, react-query | 5             | zustand는 문법이 간단하면서도 정의한 action을 이용해서만 상태를 변경할 수 있으므로, 디버깅하기 쉽습니다. 또한 필요한 상태를 구독하는 컴포넌트만 재렌더링하므로 성능 면에서도 효율적이라 선택했습니다. react-query는 서버 데이터를 다루기 위해 사용하는데 로딩과 에러 상태 그리고 캐시 등을 쉽게 다룰 수 있어서 선택했습니다. |
| **스타일링**       | emotion              | Latest (11)   | 컴포넌트처럼 스타일을 정의하고, props를 통해 동적으로 스타일 변경이 가능해 직관적이라서 선택했습니다.                                                                                                                                                                                                                        |
| **빌드 도구**      | TurboPack, Webpack   |               | 개발 환경에서 빠른 빌드를 위해 Turbopack을 사용합니다.                                                                                                                                                                                                                                                                       |
| **코드 품질 관리** | eslint               | 9             |                                                                                                                                                                                                                                                                                                                              |

---

## 📋 구현 완료 기능

> 아래 체크박스를 통해 구현 완료한 기능들을 표시해주세요.
>
> (요구사항을 모두 구현하는 것이 평가 기준은 아니며, 필수 요구사항을 모두 구현하지 못해도 추가 요구사항을 구현할 수 있습니다.)

### ✅ 필수 요구사항

- [x] 기본 페이지 및 레이아웃 구성
- [x] 공통 > 모달
- [x] 공통 > 페이지네이션
- [x] 홈 페이지 > 기본
- [x] 서비스 게시판 > 기본
- [x] 서비스 게시판 > 게시글 더보기 액션
- [x] 서비스 게시판 > 게시글 UI 타입 변경
- [x] 서비스 게시판 > 게시글 상세
- [x] 서비스 게시판 > 게시글 등록 및 수정

### 🎯 추가 요구사항

- [x] 게시글 작성 중, 페이지 이동
- [x] 도커 설정
- [ ] Module Federation 적용

---

## 💡 주요 구현 내용

> 각 페이지별로 구현한 기능과 기술적 고려사항을 설명해주세요.

### 1. 기본 페이지 및 레이아웃

- **레이아웃 UI**

  - `components/layouts`에 레이아웃 관련 컴포넌트를 모아두었습니다.
  - LNB, GNB는 추후 기능 확장, 다양한 레이아웃 필요성에 대비해 별도 컴포넌트로 분리했습니다.
  - 현재 앱 규모가 작기 때문에 레이아웃은 바로 \_app.tsx에서 씌우는 형태로 사용하였습니다.

- **라우트 구성**

  - 페이지 경로를 상수화해 한눈에 볼 수 있고, 오타를 방지할 수 있께 했습니다.
  - id path 유무로 상세/수정 페이지를 분기처리합니다.

- **콘텐츠 보기 방식 옵션**

  - zustand로 콘텐츠 보기 방식을 전역 상태로 관리하며, 제공하는 미들웨어를 활용해 브라우저 스토리지 저장 및 상태 사용을 쉽게 작성했습니다.
  - GNB에 위치한 만큼 앱 전역에서 활용하며, 확장성을 고려해 AppStore로 네이밍했습니다.

### 2. 공통 컴포넌트

- **모달**:

  - 앱 최상단에 모달 컨테이너를 위치시켜서 전역적으로 모달을 관리할 수 있게 했습니다.
  - 중첩 모달 및 FILO 요구사항 충족을 위해 zustand로 모달 상태를 배열로 관리했습니다.
  - 모달 컨테이너 내에서 모달 상태 배열로 백드롭을 제외한 컴포넌트를 렌더링해서, 중첩시에도 백드롭을 하나만 유지시킵니다.
  - 다양한 형태의 모달을 prop으로 받아 재사용할 수 있도록 설계했고, 모달들은 `/components/modals`에 작성하도록 했습니다.

- **페이지네이션**:

  - 최대 7개 페이지가 노출된다고 가정하고, 7개 초과 시 세 가지 케이스(선택 페이지가 4 이하, 5 이상, 중앙)에 맞게 계산해서 처리하도록 했습니다.
  - `/components/common`에 위치하며, 이곳 컴포넌트들은 상태를 최대한 갖지 않고, props만으로 동작하도록 설계해 재사용성과 확장성을 높였습니다.

- **기타**:
  - Button, Input, DropDown 등 공통 컴포넌트를 여러 곳에서 재사용할 것들을 고려해 작성했습니다.

### 3. 서비스 게시판

- **API 연동**

  - octokit과 react-query를 결합해 사용했으며, API 요청 함수 (`/lib/api/index`)와 요청 훅(`/hooks/queries`, `hooks/mutations`)로 분리해서 관리합니다.
  - API 요청 함수는 github 제공 형태를 유지하고, 개발하면서 별도 편의를 위한 가공이 필요한 경우 요청 훅에서 처리하도록 해 확장성과 재사용성을 높이고자 했습니다.

- **게시글 목록**:

  - Table, CardGrid 로 보기 옵션에 따른 목록 컴포넌트 분리
  - 검색 입력 필드는 비제어 컴포넌트로 개발하고, 엔터/버튼 클릭 시에만 동작하도록 했습니다.
  - 페이지 이동 시에도 히스토리 유지를 위해 검색어, 페이지번호는 queryString으로 관리합니다.
  - 페이지네이션 total count를 얻기 위해 목록/검색 모두 검색 API 활용해서 조회하도록 했습니다.

- **게시글 상세**:

  - pathparam의 issue number로 게시글 조회하여 컨텐츠 표시
  - 목록 버튼 클릭 시 뒤로가기가 아닌 이슈 목록으로 이동시켜줍니다. 상세 페이지로 다이렉트로 진입하는 케이스가 발생할 수 있어서 뒤로가기로 처리하지 않았습니다.

- **게시글 등록/수정**:

  - 동일 입력 폼을 재사용하기 위해 `FormField` 컴포넌트를 분리했습니다. issue number 유무로 등록/수정을 분기합니다.
  - 에러 메시지/폼 관리를 위해 Input, TextArea 공통컴포넌트와 react-hook-form을 활용했습니다.

### 4. 추가 요구사항

- **게시글 등록 및 수정 페이지**

  - 항상 confirm을 띄우는 대신, 실제 편집이 이뤄졌을 때 (react-hook-form의 dirty 상태) 이탈 confirm을 노출해서 UX를 개선합니다.
  - 새로고침/창닫기 시에는 beforeunload 이벤트로 커스텀할 수 없는 브라우저 기본 confirm을 띄워 데이터 손실 방지합니다.
  - 뒤로가기 시에는 router.beforePopState와 useRef를 활용해 직전 url을 저장하고, 모달에서 확인 시 해당 url로 이동하도록 처리했습니다.

---

## ⚠️ 개발 과정에서 겪은 이슈와 해결 방법

> 개발 중 발생한 문제들과 해결 과정을 기록해주세요.

| 문제 상황                                                                                                                                        | 원인 분석                                                                                                                                | 해결 방법                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 학습 내용                                                                                                                                                                                                    |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 게시글 편집 중 뒤로가기 시 confirm 을 띄우는데, 사용자가 취소 후 다시 뒤로가기를 누르면 N번 뒤로가는 이슈 발생                                   | beforePopState의 url을 콘솔에 출력해보니, false를 반환해서 popState를 발생시키지 않더라도 브라우저 히스토리 상으로는 뒤로 가는 것이 확인 | 전환하려던 첫 url만 Ref에 저장하고, 그 이후에는 저장하지 않도록 조건 처리하여 항상 직전 url로만 돌아갈가도록 해결                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 브라우저 설계 철학상 뒤로가기를 막을 수 없으며, popState는 이미 이동 후 발생하기 때문에 즉, 브라우저 레벨에서 이뤄지는 것이라 완벽하게 제어할 수 없음                                                        |
| 에러 발생 후 ErrorBoundary의 fallback이 표시된 상태에서 LNB 메뉴를 클릭해도 경로는 변경되지만 새로운 페이지가 렌더링되지 않고 에러 페이지만 보임 | fallback 상태일 때는 ErrorBoundary의 reset이 될 때 까지 자식 컴포넌트를 다시 렌더링하지 않음                                             | resetKeys prop에 현재 경로를 넣어서 경로가 바뀔 때 마다 자동으로 reset 되도록 해결                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 레이아웃 내에 ErrorBoundary를 설정한 적이 없어서 놓친 부분이었는데, reset 전 까지 자식 컴포넌트를 재렌더링 하지 않는다는 점을 알게됨                                                                         |
| 게시글 삭제/수정/등록 시 목록을 갱신하기 위해 invalidateQueries/refetch를 호출해도 목록이 즉시 갱신되지 않아 사용성 이슈가 발생                  | GitHub Search API가 실시간 반영되지 않고, 서버 데이터 최신화에 지연이 발생함을 확인함                                                    | 해결: github issues 페이지를 참고하였고 이슈 닫힘 처리 직후에는 목록에서 제거가 아니라 닫힘 표시를 해주는 것을 알았습니다. 또 이슈 등록/닫힘 시 목록으로 이동시키는게 아니라 해당 상세 페이지를 보여주는 것을 알았습니다. 이에 아이디어를 얻었습니다., 게시글 목록에 즉각적으로 추가, 삭제되지는 않지만 state는 즉시 변경되겠다고 예상했고 맞아 떨어져 github issues 페이지에서의 처리방식과 동일하게 개발해서 해결했습니다. 해결시도: 낙관적 업데이트로 프론트엔드에서 즉시 UI를 갱신했으나, 1) 삭제 시 서버 데이터가 완전히 반영되기 전까지는 목록이 10개가 아닌 9개로 노출되는 점, 2) 지연 시간이 예측 불가하여 언제 갱신할지 애매한 점, 3) 등록/수정/삭제 등 각 상황별로 후속 처리 코드가 복잡해지는 점 등의 한계가 있었음 | 데이터 일관성을 위해 유의미한 수준의 지연 이슈가 발생할 수 있음을 경험했고, API의 특성을 파악해야함을 깨달음. 낙관적 업데이트를 처음 다뤄볼 수 있었으나 다양한 케이스를 대응하기에는 고려할 것이 많음을 배움 |

---

## ▶ 실행 방법

.env파일을 추가해주세요.

```bash
# 개발 모드 실행
# Node 20.18 버전, Chrome 브라우저 기준으로 개발되었습니다.
$ npm i
$ npm run dev
```

```bash
# 도커 이미지 빌드 및 실행
$ npm run docker:build
$ npm run docker:run
```

**접속 URL**: http://localhost:3000/

---

## 📝 추가 설명

> 구현 과정에서 특별히 고민했던 부분이나 추가로 구현하고 싶었던 기능이 있다면 여기에 작성해주세요.

- **전반적인 프로젝트 구조 계획**

  - 현재 앱 규모는 작지만, 확장성과 유지보수성을 고려하고자 했습니다.
  - `pages/`는 라우팅 및 메타 정보만 담당하고 실제 컨텐츠는 `containers/`에 작성하도록 해서 책임 분리를 했습니다.
  - 공통 컴포넌트는 `components/`에 위치하고 특정 페이지 전용 컴포넌트는 `containers/components`에 위치시켰습니다.

- **API 요청 함수 및 훅 정의**

  - API 요청 함수는 별도 파일에 모아두고, react-query 훅으로 가공/재활용해서 확장성을 높였습니다.

- **게시글 등록/수정/삭제(닫음) 후 목록 갱신 지연 이슈**

  - Github search API의 지연으로 인해 게시글 조작 시 목록 갱신을 즉시 할 수 없음을 알았습니다.
  - 낙관적 업데이트는 케이스별로 대응해야함에 코드 복잡도와 한계로 채택하지 않았습니다.
  - 임의의 delay또한 정확한 delay를 예측할 수 없으면서도 UX측면 손실이 있어서 채택하지 않았습니다.
  - 목록은 즉시 업데이트되지 않더라도, state는 즉시 변경되지 않을까라는 추측에 확인해보았고 예상이 맞았습니다. 실제 github issue 서비스 처리방식을 벤치마킹해 1) 삭제 시 목록에서는 즉시 삭제되지 않더라도 삭제 표시 및 이벤트 방지하기, 2) 등록/수정 시 목록페이지를 바로 보여주지 말고 해당 상세페이지로 이동시켜서 목록 갱신 시간 확보하기 로 처리했습니다.
  - 실제 서비스 벤치 마킹과 API 특성과 예측으로 이슈 해결

## 🤖 AI 활용 내역

> 과제 진행 시 AI 도구를 활용했다면, 어떤 AI를 사용했는지와 어떻게 활용했는지 작성해주세요.

- **활용한 AI**: ChatGPT
- **활용 방법**:
  - 정답이 없어 보이는 것에 대해 최선의 선택을 하기 위한 목적으로 활용했습니다.  
    예를 들면, route path 목록을 상수화 하고자 할 때, path만 저장할지, path와 해당 title 까지 객체로 묶어 저장할 지 등이 있겠는데 AI와 논의하는 방식으로 결정에 있어 도움을 받았습니다.
  - README 문서 가독성 등 정돈을 위해 AI의 피드백을 참고해서 리스트 형태로 구조화하고 다듬었습니다.

---

## 🔗 참고 자료

> 구현 과정에서 참고한 자료가 있다면 여기에 작성해주세요.
